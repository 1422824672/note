## TCP相关知识

#### 1.TCP三次握手与四次挥手

- 序列号： 在建立连接时，由计算机生成的随机数为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数大小，用来解决网络包乱序问题
- 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收，用来解决不丢包的问题。
- 控制位：
  - ACK：该位为1时，确认应答字段变为有效，TCP规定除了最初建立连接时SYN包之外该位必须设置为1
  - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
  - SYN：该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定
  - FIN：该位为1时，表似乎今后不会再有数据发送，希望断开连接，当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位为1的TCP段

> 为什么需要TCP，TCP工作在哪一层

TCP保证了可靠的传输

TCP在传输层

> 什么是TCP

TCP是面向连接的、可靠的、基于字节流的传输层通信协议

> 什么是TCP连接

用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接

> 如何唯一确定一个TCP连接

通过TCP四元组：源地址、源端口号、目的地址、目的端口号

地址在IP头部中，端口在TCP头部中

> 有一个IP的服务器监听了一个端口，它的TCP最大连接数是多少

最大TCP连接数 = 客户端IP * 客户端的端口数

>UDP和TCP区别？应用场景是什么

TCP 准 UDP 快

TCP和UDP应用场景：

TCP：

- FTP文件传输
- HTTP/HTTPS

UDP：

- 包总量较少的通信，如DNS、SNMP等
- 视频、音频等多媒体通信
- 广播通信

> 为什么UDP头部没有首部长度字段，而TCP有首部长度字段

TCP有可变长选项字段，而UDP头部长度不会变化

> 为什么UDP头部有包长度字段，而TCP头部没有包长度字段

TCP数据长度 = IP长度 - IP头部长度 - TCP头部长度，通过计算得来

UDP为了网络设备硬件设计和处理方便，首部长度需要是4字节整数倍，所以设计了包长度字段

****

##### TCP连接建立

> TCP三次握手过程和状态变迁

- 一开始客户端和服务端都处于CLOSED状态，服务端主动监听某个接口，处于LISTEN状态

- 三次握手第一个报文：客户端随机初始化序列号，将序列号置于TCP头部的序号字段中，同时把SYN标志位置为1，表示SYN报文，接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态
- 三次握手第二个报文：服务端收到客户端的SYN报文后，服务端也随机初始化自己的序号，将此序号填入TCP头部字段中，其次把TCP头部的确认应答号字段填入 client_isn + 1，接着把SYN和ACK标志位置为1，最后把该报文发送给客户端，该报文也不包含应用层数据，之后服务端处于SYN-RCVD状态
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP头部ACK标志位置为1，其次确认应答号字段填入server_isn + 1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于ESTABLISHED状态
- 服务器收到客户端的应答报文后，也进入ESTABLISHED状态

TCP三次握手的前两次式可以携带数据的

> 如何在Linux系统中查看TCP状态

通过netstat -napt命令查看

> 为什么是三次握手，不是两次四次

- 阻止重复历史连接的初始化

当旧的SYN报文比新的早到达了服务端，那么服务器就会返回一个SYN+ACK报文给客户端

客户端根据自身上下文，判断是一个历史连接，则发送RST报文给客户端，表示中止这次连接

两次握手没法判断，就像你告诉一个人买一包烟，后来又加了一句算了不买烟了买一包槟榔吧，如果那个人听到的是买一包烟，他没有听到不买烟了买一包槟榔，那他已经踏上买烟的路上了，你也只能拿到一包烟了，如果三次握手，他会先问你一下，买一包烟，对吗？这时你可以将新的信息告诉他

- 同步双方的初始序列号

序列号作用

接收方可以去除重复的数据；

接收方可以根据数据包的序列号按序接收；

可以标识发送出去的数据包中， 哪些是已经被对方收到的；

- 避免资源浪费

网络阻塞造成不必要的资源浪费

当客户端的SYN报文被阻塞，则会发送新的SYN报文，然后服务端直接发送SYN和ACK，然后建立了连接，那么当被阻塞的SYN报文到达服务端后，服务器会认为客户端还要建立连接，则回再次建立一个连接

> 既然IP层会分片，为什么TCP层还需要MSS呢

- MTU：一个网络包的最大长度，以太网中一般为1500字节
- MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度

IP分片较大，如果IP中有分片丢失，那么整个数据包都要重传，IP层没有重传功能，那么整个重传任务就交给了TCP，那不如TCP直接分片，分片大小小于MSS，这样IP层就不用进行分片了，那么即使丢失了哪片，TCP也只需要重传TCP分片大小的数据就够了

###### SYN攻击

伪造不同IP地址的SYN报文，服务器发送出去的ACK+SYN报文得不到回应，则会沾满服务端的SYN接收队列

避免方式：

- 修改Linux内核参数，控制队列大小和当队列满的时候应作什么处理
- 如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满

****

##### TCP连接断开

> TCP四次挥手过程和状态变迁

- 客户端发起关闭连接的请求，发送一个TCP头部的FIN标志位被置为1的报文，之后客户端进入FIN_WAIT_1状态
- 服务端收到该报文，就向客户端发送ACK报文，表示应答，接着服务端进入CLOSED_WAIT状态
- 客户端收到服务端的ACK应答报文后，进入FIN_WAIT_2的状态
- 等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态
- 客户端收到服务端的FIN报文后，回应一个ACK应答报文，之后进入TIME_WAIT状态
- 服务器收到了ACK应答报文之后，进入了CLOSED状态，至此服务端已经完成连接的关闭
- 客户端经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成了连接的关闭

MSL报文最大生存时间

主动关闭方会有TIME-WAIT状态

TIME-WAIT防止相同四元组的旧数据包被收到

保证被动关闭连接方能被正确的关闭，保证最后ACK能被正确的接收

> TIME_WAIT过多的危害

- 内存资源占用
- 端口资源占用

> 已经建立连接，客户端突然出现故障了怎么办

TCP的保活机制

##### Socket编程

> 针对TCP应该如何Socket编程？

- 服务端和客户端初始化 socket ，得到⽂件描述符；

- 服务端调⽤ bind ，将绑定在 IP 地址和端⼝;

- 服务端调⽤ listen ，进⾏监听；

- 服务端调⽤ accept ，等待客户端连接；

- 客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；

- 服务端 accept 返回⽤于传输的 socket 的⽂件描述符；

- 客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；

- 客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭。

监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作**监听** **socket**，⼀个叫作**已完**

**成连接** **socket**。

> listen 时候参数 backlog 的意义？

Linux内核中会维护两个队列：

- 未完成连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态；

- 已完成连接队列（Accpet 队列）：已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态；

- 参数⼀ socketfd 为 socketfd ⽂件描述符

- 参数⼆ backlog，这参数在历史版本有⼀定的变化

在早期 Linux 内核 backlog 是 SYN 队列⼤⼩，也就是未完成的队列⼤⼩。

在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建⽴的队列⻓度，**所以现在通常认为**

**backlog** **是** **accept** **队列。**

但是上限值是内核参数somaxcon'n

> accept 发⽣在三次握⼿的哪⼀步？

**客户端** **connect** **成功返回是在第⼆次握手，服务端** **accept** **成功返回是在三次握**

**手成功之后。**

#### 2.TCP重传、滑动窗口、流量控制、拥塞控制

##### 重传机制

