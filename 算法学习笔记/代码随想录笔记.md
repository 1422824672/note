## 代码随想录笔记

#### 数组

- 有序不重复，是否应该考虑二分查找法，注意选取的区间 -- 704.二分查找 时间复杂度为O(logn)，注意循环不变量！！！ **[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/) **O(n^2)
- 双指针法，通过两个指针，在一个for循环中完成两个for循环操作 个人认为就是减少for循环，从而降低时间复杂度 -- **[27. 移除元素](https://leetcode-cn.com/problems/remove-element)** 时间复杂度为O(n) **[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array)** 时间复杂度为O(n)
- 滑动窗口，可以理解为双指针的一种，主要在于如何控制窗口滑动，要点就是头指针的滑动规则 -- **[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum)**  时间复杂度为O(n)

****

#### 链表

- 删除头节点，可以利用创建一个虚拟头节点的方式，避免了判断删除的节点是否为头节点 **[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)** O(n)
- 反转链表，巧妙地用到了双指针 **[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)**
- 交换链表节点这道题用了递归的方法，看了好久，递归本质我觉得就是完成运算缺少的参数是由目前参与运算的已知参数推导出来的，那么入参必是已知的，返回值必是不包含已知的，并且入参具有变动性。**[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)**
- **[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)**这道题，还是运用了双指针法，总结发现双指针法有效避免了两次重复扫描的问题，还是用虚拟头节点来操作，这样可以便于当测试用例中涉及到头节点时，方便操作。
- **[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)** 这道题也算是双指针的一种体现吧
- **[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) **更多的是对指针的应用，里面有一些数学逻辑，我发现当这种图形结构较为复杂的题，画图仍然是最快最有效的提供思路的方法

****

#### 哈希表

- **[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)** 通过利用小写字母在ASCII中排列连续特性，来实现0(n)的时间复杂度
- **[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)** 通过利用语言本身的容器特质来完成这道题，用Set集合的去重性质
- **[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)** 仍然是利用set去重的性质
- **[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)** 利用map去重的性质和contains方法比较的性质，省去了暴力解法的一个for循环
- **[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)** 还是利用map去重来保证唯一性，k为两数相加值，v为此值出现次数
- **[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)** 此题和 **[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)** 类似
- **[15. 三数之和](https://leetcode-cn.com/problems/3sum/)** 此题用双（三）指针法更好两个循环做到了3个循环的事情
- **[18. 四数之和](https://leetcode-cn.com/problems/4sum/)** 和三数之和都是一个套路，降低时间复杂度，也就是降低了一个for循环

****

#### 字符串

- **[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)** 本题主要使用了双指针法，妙用了异或位运算，也就是当 a^b == c时，c^a == b 或 c^b == a
- **[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)** 本题在反转部分和上题一样，主要是控制边界条件，找到循环不变量，主要卡壳的问题是没有确定清楚指针的位置。
- **[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)** 这道题核心思想在于避免内存占用，在原有基础上扩展数组，指针从后向前扫描，这样避免了需要“模板组”字符串来对照，因为模板组在前。
- ***[151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)*** 这道题限制条件过多，需要好好分析，分成三部分来做，去空格，整体反转，单个反转，则可达到效果。
- **[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)** 同样是与上题一样，进行两次反转。

###### KMP算法

1.定义：三位发明者的名字拼写，因此叫做KMP算法

2.所解决问题：字符串匹配的问题，若出现了不匹配，如何充分利用已匹配部分

例：给出一个文本串aabaabaaf，给出一个模式串aabaaf， 找出与文本串相匹配的内容。

给出以下定义：

3.前缀：包含首字母不包含尾字母的所有子串都成为前缀

4.后缀：包含尾字母不包含首字母的所有子串都成为后缀

5.最长相等前后缀：前缀与后缀最长匹配长度

- **[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)** 虽然是很简单的题，但是用KMP算法做起来，KMP思想有些复杂，重点在于节约了重复扫描已知部分，实在太难了。
- **[459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)** 同样利用KMP算法，用长度 除余 长度 减去 最后一个元素的最大相同前后缀坐标，如果为0，证明有一个或多个重复子字符串

****

#### 栈和队列

- **[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)** 考察了栈的基本操作，pop弹出，peak返回栈顶元素，isEmpty判断是否为空
- **[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)** 主要考查了队列的基本操作
- **[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)** 通过此题发现大多数对称匹配类题目都可以用栈去做，将待匹配的另一半存入栈，当另一半变成待匹配时，可以看是否与栈顶元素相等，就可以判断是否对称匹配
- **[1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)** 此题也和匹配问题差不多，利用栈结构可以做到，需要注意的是字符串的拼接顺序
- **[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)** 波兰表达式是后缀表达式的方式，这种方式适合计算机访问，而这种结构又可以通过二叉树的后序遍历来完成，二叉树又可以由栈来做出
- **[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)** 此题重点在于自己构造合适的单调队列，单调数据结构可以很好的解决一些有序问题
- **[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)** 使用优先级队列来排序，通过map来统计次数，超出容量就弹出最小的，剩下的就是频率最大的

****

#### 二叉树

二叉树定义：

- 满二叉树： 只有度为0或2的节点，并且度为0的在同一层上，深度为k，有2^k -1 个节点
- 完全二叉树： 除最底层没被填满外，其余都被填满，并且所有叶子节点在左侧
- 二叉搜索树： 若左子树不空，左子树大于根节点值；若右子树不空，右子树小于根节点值
- 平衡二叉搜索树： AVL树，左右两个子树高度差不超过1

二叉树可以链式存储也可以用数组存储，数组存储第i个节点为i\*2+1为左，i\*2+1为右

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

##### 二叉树的递归遍历

1.确定递归的参数和返回值类型

2.确定递归的终止条件

3.确定单层递归的逻辑

- **[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)** 
- **[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)**
- **[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)** 三种二叉树深度优先遍历方式，可以使用递归和迭代两种方式实现，做二叉树的题，切忌想太多
- 
